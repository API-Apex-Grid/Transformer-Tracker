name: Backend Docker build

on:
  workflow_run:
    workflows: ["Merge main into target"]
    types:
      - completed

permissions:
  contents: read

jobs:
  detect-and-build:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine target branch
        run: |
          set -euo pipefail
          if command -v jq >/dev/null 2>&1; then
            TARGET=$(jq -r '.workflow_run.pull_requests[0].base.ref // .workflow_run.head_branch // empty' "$GITHUB_EVENT_PATH" || true)
          else
            TARGET="${{ github.event.workflow_run.head_branch }}"
          fi
          if [ -z "${TARGET:-}" ]; then
            echo "TRIGGER_BRANCH=local" >> $GITHUB_ENV
            echo "Determined TRIGGER_BRANCH=local"
          else
            echo "TRIGGER_BRANCH=$TARGET" >> $GITHUB_ENV
            echo "Determined TRIGGER_BRANCH=$TARGET"
          fi

      - name: Detect backend changes between target and main
        id: detect
        run: |
          set -euo pipefail
          TARGET=${TRIGGER_BRANCH:-local}
          echo "Detecting changes related to backend/ for workflow run. Target branch: $TARGET"
          # Always fetch main so we have the merged commit available
          git fetch origin main

          # Prefer to use the workflow_run.head_sha (the commit produced by the merge/run)
          if command -v jq >/dev/null 2>&1; then
            HEAD_SHA=$(jq -r '.workflow_run.head_sha // empty' "$GITHUB_EVENT_PATH" || true)
          else
            HEAD_SHA="${{ github.event.workflow_run.head_sha }}"
          fi

          CHANGED=""
          if [ -n "${HEAD_SHA:-}" ]; then
            echo "Found workflow head SHA: $HEAD_SHA — attempting to list files changed in that commit"
            # Try to show files for that SHA. If it's not present locally, try fetching it (fetching main should normally fetch it).
            if git rev-parse --verify "$HEAD_SHA" >/dev/null 2>&1; then
              CHANGED=$(git show --name-only --pretty="" "$HEAD_SHA" || true)
            else
              git fetch origin "$HEAD_SHA" || true
              CHANGED=$(git show --name-only --pretty="" "$HEAD_SHA" || true)
            fi
          fi

          # If we didn't get any changed files from the head SHA, fall back to comparing branches
          if [ -z "${CHANGED:-}" ]; then
            echo "No files found for head SHA — falling back to comparing origin/$TARGET..origin/main"
            git fetch origin "$TARGET" || true
            if git ls-remote --exit-code --heads origin "$TARGET" >/dev/null 2>&1; then
              # Use merge-base (three-dot) diff so we capture files introduced by the merge commit(s)
              CHANGED=$(git diff --name-only origin/main...origin/$TARGET || true)
            else
              echo "origin/$TARGET not found — treating as changed"
              CHANGED="backend/"
            fi
          fi

          echo "Changed files:\n$CHANGED"
          if printf "%s" "$CHANGED" | grep -E '^backend/' >/dev/null 2>&1; then
            echo "backend_changed=true" >> $GITHUB_OUTPUT
          else
            echo "backend_changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Build and push Docker image
        if: steps.detect.outputs.backend_changed == 'true'
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          set -euo pipefail
          echo "Backend changed — building image"
          echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin
          docker build -t "$DOCKERHUB_USERNAME/transformer-tracker-local:latest" backend
          docker push "$DOCKERHUB_USERNAME/transformer-tracker-local:latest"
